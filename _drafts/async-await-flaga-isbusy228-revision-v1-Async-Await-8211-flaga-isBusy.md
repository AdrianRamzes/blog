---
id: 231
title: 'Async Await &#8211; flaga isBusy'
date: 2015-04-15T12:43:26+00:00
author: admin
layout: revision
guid: http://www.karalus.eu/2015/04/228-revision-v1/
permalink: /2015/04/228-revision-v1/
---
ZaÅ‚Ã³Å¼my, Å¼e nasze asynchroniczne zadanie odpalane jest na jakiÅ› event, np. klikniÄ™cie przycisku.  
<!--more-->

  
Co jeÅ›li zadanie jest doÅ›Ä‡ wyczerpujÄ…ce, a na dodatek nie powinno byÄ‡ wywoÅ‚ywane wiÄ™cej niÅ¼ raz w krÃ³tkim czasie? (przez zniecierpliwionego uÅ¼ytkownika, ktÃ³ry klika po kilka razy w ten sam przycisk bo myÅ›li, Å¼e to pomoÅ¼e).

W takim przypadku powinniÅ›my przede wszystkim, poinformowaÄ‡ uÅ¼ytkownika, Å¼e trwajÄ… obliczenia (jakaÅ› grafika &#8211; busy indicator) oraz zablokowaÄ‡ przycisk, tak aby nie moÅ¼na byÅ‚o juÅ¼ w niego kliknÄ…Ä‡.

Super. Pewnie to wystarczy. A co jeÅ›li zdarzeniem nie jest klikniÄ™cie przycisku tylko cokolwiek innego, byÄ‡ moÅ¼e nie zwiÄ…zanego z interfejsem uÅ¼ytkownika.  
Generalnie, przyda siÄ™ flaga, ktÃ³ra bÄ™dzie stawiana gdy obliczenia siÄ™ wykonujÄ… &#8211; odpowiednik IsBusy w klasie BackgroundWorker.

RozwiÄ…zanie jest banalne.

<pre class="brush: csharp; title: ; notranslate" title="">private bool isBusy = false;
        private async void sthAsync(object sender, EventArgs e)
        {
            if (!isBusy)
            {
                isBusy = true;
                await someTaskAsync();
                isBusy = false;
            }
        }

        private Task someTaskAsync()
        {
            return Task.Run(() =&gt;
            {
                Thread.Sleep(2 * 1000);// 1000ms = 1s
            });
        }
</pre>

To czy metoda asynchroniczna bÄ™dzie wywoÅ‚ana uzaleÅ¼niamy od wartoÅ›ci flagi isBusy.  
Przed i po wywoÅ‚aniu metody asynchronicznej ze sÅ‚Ã³wkiem await, zmieniamy wartoÅ›Ä‡ flagi isBusy.

To tyle. Tym razem kodu nie umieszczam na GITHUB, poniewaÅ¼ caÅ‚y potrzebny kod jest w tym wpisie ğŸ˜‰